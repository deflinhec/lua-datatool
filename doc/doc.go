package doc

import (
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"os"
	"strings"

	"datatool.deflinhec.dev/formatter"
	"github.com/deflinhec/runtimelua/luaconv"
	lua "github.com/yuin/gopher-lua"
)

type FileInfo struct {
	Namespace string
	Filename  string
	Field     string
	Md5Sum    string
}

type File struct {
	FileInfo
	Value interface{}
}

func newLuaState() *lua.LState {
	l := lua.NewState(lua.Options{
		CallStackSize:       128,
		RegistryGrowStep:    128,
		RegistryMaxSize:     128,
		SkipOpenLibs:        true,
		IncludeGoStackTrace: true,
	})
	for name, lib := range map[string]lua.LGFunction{
		lua.BaseLibName:   lua.OpenBase,
		lua.TabLibName:    lua.OpenTable,
		lua.IoLibName:     lua.OpenIo,
		lua.StringLibName: lua.OpenString,
		lua.MathLibName:   lua.OpenMath,
		lua.LoadLibName:   lua.OpenPackage,
	} {
		l.Push(l.NewFunction(lib))
		l.Push(lua.LString(name))
		l.Call(1, 0)
	}
	return l
}

func OpenFile(filename string) (*File, error) {
	l := newLuaState()
	defer l.Close()

	b, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	} else if err := l.DoString(string(b)); err != nil {
		return nil, err
	}

	// Search for the namespace and field from loaded file.
	info := &FileInfo{Filename: filename}
	if loaded, ok := l.G.Registry.RawGetString("_LOADED").(*lua.LTable); ok {
		md5sumTable := l.CreateTable(0, 0)
		loaded.ForEach(func(key, value lua.LValue) {
			if strings.HasPrefix(key.String(), "_") {
				return
			} else if table, ok := value.(*lua.LTable); ok {
				switch key.String() {
				case "_G":
				case lua.IoLibName:
				case lua.TabLibName:
				case lua.MathLibName:
				case lua.StringLibName:
				default:
					table.ForEach(func(key, value lua.LValue) {
						if strings.HasPrefix(key.String(), "_") {
							return
						} else if _, ok := value.(*lua.LTable); ok {
							switch key.String() {
							case "md5sum":
								md5sumTable = value.(*lua.LTable)
							default:
								info.Field = key.String()
							}
						}
					})
					info.Namespace = key.String()
					info.Md5Sum = md5sumTable.RawGetString(info.Field).String()
				}
			}
		})
	}

	// Retrieve the value from lua runtime and convert to golang structure.
	var value interface{}
	if namespace, ok := l.G.Global.RawGetString(info.Namespace).(*lua.LTable); !ok {
		return nil, fmt.Errorf("namespace %v is not a table", info.Namespace)
	} else if rows, ok := namespace.RawGetString(info.Field).(*lua.LTable); !ok {
		return nil, fmt.Errorf("namespace %v does not have field %v", info.Namespace, info.Field)
	} else if value = luaconv.LuaValue(formatter.EscapeNonStringKeys(l, rows)); value == nil {
		return nil, fmt.Errorf("failed to convert lua value")
	}

	return &File{Value: value, FileInfo: *info}, nil
}

func (f *File) Save() error {
	file, err := os.Create(f.Filename)
	if err != nil {
		return err
	}
	defer file.Close()

	body := formatter.Format(f.Field, f.Value,
		formatter.KeySort(formatter.KeySortHashFnv64),
	)
	hash := md5.Sum([]byte(body))

	if _, err := file.WriteString(`
-- This file is formated by datatool, DO NOT EDIT THIS FILE.
-- $id$
module("` + f.Namespace + `")
md5sum = md5sum or {}
md5sum.` + f.Field + `="` + hex.EncodeToString(hash[:]) + `"
` + body + `
		`); err != nil {
		return err
	}
	return nil
}

func (f *File) SaveTo(fileaname string) error {
	f.Filename = fileaname
	return f.Save()
}
